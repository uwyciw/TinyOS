# TinyOS

English Readme is [here](README-EN.md).

TinyOS是一款非抢占式、弱优先级、所有任务共用一个栈空间的精简内核。其设计主旨是为那些对实时性、并发性要求不高，但又需要将整体业务逻辑分拆到多个相对独立的任务中，且任务与任务间、任务与外部输入间有基础的事件交互需求的场景提供一个OS内核。

## 特色
- TinyOS以极致精简为设计主旨，在资源消耗上无限接近裸机编程；
- 内核不支持任务抢占，也没有为各任务配置栈空间，每次任务执行都等同于对任务函数的一次普通调用，所有任务函数都依次在主栈上执行；
- 任务需要在内核启动前，在任务数组内完成声明，根据数组内的排序，会隐式定义优先级，数组第一个元素优先级最高，该方式尽管牺牲了任务创建的灵活性，但可以节省很多资源；
- 仅提供一种简单的事件类型，即可以被当作信号类事件，也可以被当作计时类事件；
- 计时单元仅支持滴答(tick)数，不支持时间单位，且不要求每次时钟滴答都调用定时函数，这样的做法对一些低功耗场景很友好；

## 事件
- 事件在被使用前，必须与一个任务进行绑定的，且绑定后无法解绑，每个任务至多可以绑定32个事件；
- 当事件被触发后，与其绑定的任务就会处于激活状态，内核就会在恰当时机对其调度；
- 任务一旦被执行，那么其绑定的所有事件都会回归至非触发态；
- 尽管内核只提供一种事件类型，但其可以被当作信号类事件，也可以被当作计时类事件；
  - 当事件作为非计数型信号类事件使用时，可以通过`Post`函数，向事件发送信号触发事件；
  - 当事件作为计时类事件使用时，可以通过`Timeout`函数，将事件加入定时器队列，等待超时触发事件；
- 内核提供声明事件专用的宏`__OS_EVENT_ALLOC`；
- 事件的类型定义如下：
```
typedef struct os_event_t {
    int Id;                   // 事件对应任务的ID。
    uint32_t Mask;            // 事件掩码。
    uint32_t Timeout;         // 事件超时。
    struct os_event_t * Next; // 事件链表指针。
} OS_EVENT_T;
```

## 任务
- 出于极简设计的考虑，任务被简化为两个函数，一个可选的初始化函数，一个必选的主函数；
  - 初始化函数在内核启动阶段，按照优先级依次执行一次，推荐用于执行事件绑定操作；
  - 每次处于激活状态的任务被内核调度执行时，都会调用一次主函数，因为这仅是一次普通的函数调用，所以主函数内局部变量的生命周期，与一般RTOS任务函数的局部变量有区别，需要特别注意；
- 在任务的主函数内，需要调用`Assert`函数，来判断本次任务是被哪些事件激活的，并做出相应处理；
- 内核提供声明任务专用的宏`__OS_TASK_INSERT`；
- 在启动内核前，需要先声明任务数组，并在启动内核时，将任务数组传入内核，任务数组的类型为任务控制块`OS_TCB_T`；
- 任务控制块的类型定义如下：
```
typedef struct {
    int Id;        // 任务ID。
    void * Init;   // 初始化函数。
    void * Task;   // 任务函数。
    uint32_t Flag; // 就绪事件标志。
    int Counter;   // 此任务已经分配的事件数目。
} OS_TCB_T;
```

## 调度
- 内核在每轮调度时，会按照任务数组的顺序，逐一检查每个任务是否被激活；
- 若检查到某一任务处于激活状态，会先拷贝该任务各事件的触发状态，再将该任务各事件复位至非触发状态，然后再执行该任务的主函数；
- 当前任务的主函数执行完成后，内核会从任务数组的第一元素（即优先级最高的任务）开始，重新检查各任务是否被激活；

## 定时器
- 当一个事件被用作计时类事件时，其就相当于一个定时器；
- 所有的定时器都是单次的，即内核中没有周期定时器，任务可以在定时器超时后，重新启动来实现周期定时；

## 目录概览
```
.
├── core
│   ├── inc
│   │    ├── os.h             # 对外接口头文件
│   │    └── os_internal.h    # 内部头文件
│   └── src
│        └── os.c             # 内核代码
└── _example                  # 一个例程，在ST的NUCLEO-L053R8运行，可以使用STM32CubeMX产生工程代码
```
